#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
# csv2odf  v1.03
# Copyright (C) 2009 Larry Jordan <w322 at users.sourceforge.net>
#
# csv2odf is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# csv2odf is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#

# Objects:
# Instance		Type
# --------		-----------------------
# app			application_initializer
# document		document_processor
# data			incoming_data_source

from __future__ import print_function  # For python 2.6 print function compatibility

import getopt, shlex, sys, os

def _(string=""):	#support for localization, not yet implemented
	return string

class application_initializer:

	# properties
	quiet = 0
	verbose = 0
	showhelp = 0
	xml = 0
	nodata = 0
	start = 0
	end = 0
	header_from_csv = 0
	colSkips = 0
	rowSkips = 0
	delimiter = ','
	dateformat = ""
	order = []
	document_file = ""
	csv_file = ""
	out_file = ""

	def help(self):
		print(_("USAGE: csv2odf [OPTION] CSV TEMPLATE OUTPUT"))
		print()
		print(_("csv2odf is a command line tool that can convert a comma seperated value"))
		print(_("(csv) file to an ods or odt document.  csv2odf is useful  for  creating"))
		print(_("reports  from  databases and other data sources that produce csv files."))
		print(_("csv2odf can be combined with cron and shell  scripts  to  automatically"))
		print(_("generate business reports."))
		print()
		print(_("The csv data is merged with a template file to produce the output file."))
		print(_("The template is a standard open document file as  produced  by  OpenOf-"))
		print(_("fice.org.   The  template  can  be a spreadsheet file (ods) or document"))
		print(_("file (odt)."))
		print()
		print(_("If the template is a spreadsheet, the first row will be  treated  as  a"))
		print(_("header  row.   (Override with -H)  The second row is repeated for every"))
		print(_("row in the csv file.  The formatting in the second row  cells  will  be"))
		print(_("applied  to  each  data cell of the output file.  In a spreadsheet tem-"))
		print(_("plate, the second row needs to contain some data: cells that  may  con-"))
		print(_("tain  letters  (not  just  numbers) should have letters; adjacent cells"))
		print(_("should not contain repeated data or else OpenOffice may  merge/compress"))
		print(_("them."))
		print()
		print(_("If  the  template  is  a document, it must contain a table that the csv"))
		print(_("data will be inserted into.  The table will be processed the same as  a"))
		print(_("spreadsheet."))
		print()
		print(_("In  the  header  or footer of the template, you can insert a [date] tag"))
		print(_('(the word "date" enclosed in brackets).  The date tag will be  replaced'))
		print(_("by the current date.  The date format can be changed using format codes"))
		print(_("(see below), for example [date  %Y-%m-%d]  will  produce  a  date  like"))
		print(_("2008-02-04.  A date with a day offset from the current date can be cre-"))
		print(_("ated by using +n or -n, for example  [date-1]  would  insert  the  date"))
		print(_("before today."))
		print()
		print(_("The  options  may  be  placed  in  the  template file.  To do this, put"))
		print(_('"csv2odf:" (without qoutes) followed by the options in the  first  cell'))
		print(_("(cell  A1).   Note  the  first  row  will  be  deleted when it contains"))
		print(_("options."))
		print()
		print(_("OPTIONS"))
		print(_("-h     displays help information"))
		print(_("-v     verbose mode"))
		print(_("-H     insert the first csv row into the header"))
		print(_("-c <char>"))
		print(_("       use char as delimiter instead of comma"))
		print(_("-o <spec>"))
		print(_("       specify  column order: 2,1,3 = second csv column is first.  Also"))
		print(_("       use to leave the contents of a template column: 1,2,,3,4  =  the"))
		print(_("       3rd template column is not overwritten.  Useful if a column con-"))
		print(_("       tains a formula.  The formula cell references will be offset  to"))
		print(_("       the correct row."))
		print(_("-s <n> start reading at the nth row of the csv file"))
		print(_("-e <n> end reading at the nth row of the csv file"))
		print(_("-S <n> skip  the  first n rows of the template file, the header will"))
		print(_("       be the next row after those skipped"))
		print(_("-d <fmt>"))
		print(_("       date format within csv data is specified by fmt string, see -D"))
		print(_("       for codes"))
		print(_("-D     show a list of date format codes"))
		print(_("-q     suppress all warning messages"))
		print(_("-x     create an xml output file instead of odf"))
		print(_("-n     do not  merge the  data into output, "))
		print(_("          use with -x to extract template xml codes"))
		print(_("--input=<file>"))
		print(_("       specify the csv data file location"))
		print(_("--template=<file>"))
		print(_("       specify the tempate file location"))
		print(_("--output=<file>"))
		print(_("       specify the output file location"))

	def datehelp(self):
		print(_("These codes may be used with the -d option."))
		print(_("%a     Locale's abbreviated weekday name."))
		print(_("%A     Locale's full weekday name."))
		print(_("%b     Locale's abbreviated month name."))
		print(_("%B     Locale's full month name."))
		print(_("%c     Locale's appropriate date and time representation."))
		print(_("%d     Day of the month as a decimal number [01,31]."))
		print(_("%H     Hour (24-hour clock) as a decimal number [00,23]."))
		print(_("%I     Hour (12-hour clock) as a decimal number [01,12]."))
		print(_("%j     Day of the year as a decimal number [001,366]."))
		print(_("%m     Month as a decimal number [01,12]."))
		print(_("%M     Minute as a decimal number [00,59]."))
		print(_("%p     Locale's equivalent of either AM or PM."))
		print(_("%S     Second as a decimal number [00,61]."))
		print(_("%U     Week number of the year (Sunday as the first day of the week)"))
		print(_("          as a decimal number [00,53]. All days in a new year preceding"))
		print(_("          the first Sunday are considered to be in week 0"))
		print(_("%w     Weekday as a decimal number [0(Sunday),6]."))
		print(_("%W     Week number of the year (Monday as the first day of the week)"))
		print(_("          as a decimal number [00,53]. All days in a new year preceding"))
		print(_("          the first Monday are considered to be in week 0."))
		print(_("%x     Locale's appropriate date representation."))
		print(_("%X     Locale's appropriate time representation."))
		print(_("%y     Year without century as a decimal number [00,99]."))
		print(_("%Y     Year with century as a decimal number."))
		print(_("%Z     Time zone name (no characters if no time zone exists)."))
		print(_('%%     A literal "%" character.'))

	def stop(self, message="", errnum=0):
		'''Terminate the program with a message.'''
		print(message)
		sys.exit(errnum)

	def extension(self, string):
		'''Return the file type part of the file name.'''
		dot = string.rfind(".")
		if dot > 0:
			return string[dot+1:]
		else:
			return ""

	def int_minus_1(self, string):
		'''Converts a string to an integer and subtracts 1. '''
		if string:
			try:
				n = int(string)
			except ValueError:
				print(_("Error:"), string, _("does not look like a number"))
				sys.exit(1)
			if n < 1:
				print(_("Error:"), string, _("cannot be less than 1"))
				sys.exit(1)
			return n - 1
		else:
			return None

	def get_args(self):
		'''get command line arguments'''
		arguments = sys.argv[1:]
		if arguments:
			self.parse_args(arguments)
		else:  # no arguments were provided, show help
			self.help()
			sys.exit(0)

	def parse_args(self, arguments):
		'''parse arguments'''
		EN_DASH = '\xe2\x80\x93'
		if type(arguments) is str:  # if arguments is a string, split it into a list.
			arguments = arguments.replace(EN_DASH, '--')  # openoffice may sometimes replace a double-dash with an en-dash (unicode 2013), change it to double-dash.
			arguments = shlex.split(arguments)
		elif sys.version_info[0] == 2 and type(arguments) is unicode:  # if arguments is a unicode string, split it into a list.
			arguments = arguments.replace(EN_DASH.decode('utf-8'), '--').encode()  # openoffice may sometimes replace a double-dash with an en-dash (unicode 2013), change it to double-dash.
			arguments = shlex.split(arguments)
		try:
			optionlist, argumentlist = getopt.gnu_getopt(arguments, "hHqvxnzs:e:c:Dd:S:o:", ["input=", "template=", "output="])
		except getopt.GetoptError:
			self.help()
			sys.exit(1)
		for o, a in optionlist:
			if o == "-h": self.showhelp = 1
			elif o == "-q": self.quiet = 1
			elif o == "-v": self.verbose = 1
			elif o == "-x": self.xml = 1
			elif o == "-n": self.nodata = 1
			elif o == "-c": self.delimiter = a
			elif o == "-d": self.dateformat = a
			elif o == "-o":
				self.order = list(map( self.int_minus_1, a.split(",") ))
				for i in range(len(self.order)):
					if self.order[i] == None:
						self.colSkips += 1
			elif o == "-D":
				self.datehelp()
				sys.exit(0)
			elif o == "-H": self.header_from_csv = 1
			elif o == "-s":
				try:
					self.start = int(a)
				except ValueError:
					self.stop(_("Error: ")+a+_(" does not look like a number"), 1)
			elif o == "-S":
				try:
					self.rowSkips = int(a)
				except ValueError:
					self.stop(_("Error: ")+a+_(" does not look like a number"), 1)
			elif o == "-e":
				try:
					self.end = int(a)
				except ValueError:
					self.stop(_("Error: ")+a+_(" does not look like a number"), 1)
			elif o == "--input":
				self.csv_file = a
			elif o == "--template":
				self.document_file = a
			elif o == "--output":
				self.out_file = a
			elif o == "-z":
				self.debug = 1
				self.xml = 1
				self.quiet = 1
			else:
				self.stop(_("Error: Unrecognized option "+o), 1)
		if self.showhelp:
			self.help()
			if argumentlist and not self.quiet:
				print()
				print(_("Warning: when help is displayed, no files are processsed"))
			sys.exit(0)
		#parse and validate arguments
		for argument in argumentlist:
			if self.extension(argument) in ('ods', 'odt'):
				if not self.document_file:
					self.document_file = argument
				elif not self.out_file:
					self.out_file = argument
				#else:
				#	self.stop(_("Error: expected two files of ods/odt type, got more than two"), 1)
			elif self.extension(argument) == 'csv':
				if not self.csv_file:
					self.csv_file = argument
				else:
					self.stop(_("Error: expected one file of csv type, got more than one"), 1)
			elif self.extension(argument) == 'xml':
				if not self.out_file:
					self.out_file = argument
					self.xml = 1
					if self.verbose: print(_("Producing xml output file"))
			elif argument == argumentlist[2] and self.document_file and self.csv_file and not self.out_file:
				#out_file has not been identified but both other files have, just use the 3rd argument
				self.out_file = argument
		if not self.document_file: self.stop(_("Error: could not identify the template file in the given arguments."), 1)

	def test_args(self):
		if not self.out_file: self.stop(_("Error: could not identify the output file in the given arguments."), 1)
		if not self.csv_file:
			self.nodata = 1
			if not self.quiet: print(_("Warning: there was no csv file specified, output will have no data added."))
		if not self.extension(self.document_file) == self.extension(self.out_file) and not (self.quiet or self.xml):
			print(_("Warning: the template and output files should be of the same type."))
		if not os.path.exists(self.document_file): self.stop(_("Error: file was not found: ")+self.document_file, 1)
		if (not self.nodata) and (not os.path.exists(self.csv_file)): self.stop(_("Error: file was not found: ")+self.csv_file, 1)

	def __init__(self):
		self.get_args()

	# end class application_initializer

class document_processor:

	import zipfile, time, re
	import xml.dom.minidom

	#properties
	filename = ""  # string containing the source filename
	content = ""  # the xml document object model
	initial_offset = 0

	def __init__(self, filename):
		self.filename = filename
		self.read_odf()

	def read_odf(self):
		'''Read an odf file (either odt or ods) and parse content'''
		documentfile = self.zipfile.ZipFile(self.filename,'r')
		if sys.version_info[0] >= 3:
			self.content = self.xml.dom.minidom.parseString(documentfile.read("content.xml").decode("UTF-8"))
		elif sys.version_info[0] == 2 and sys.version_info[1] >= 6:
			self.content = self.xml.dom.minidom.parseString(documentfile.read("content.xml"))
		else:
			documentfile.close()
			self.stop(_("Error: Your Python version is too old, this program requires version 2.6 or greater"), 1)
		documentfile.close()
		try:
			firstcell = self.content.getElementsByTagName('table:table-cell')[0].firstChild.firstChild
		except:
			firstcell = self.content.createTextNode("")
		if firstcell.data[:8].lower() == 'csv2odf:':  # The first cell contains options
			app.parse_args(firstcell.data[8:])
			app.get_args()  # we want command line args to override args in the template, so reload the command line args
			parent = firstcell.parentNode
			while (not parent.tagName == 'table:table-row') and (not parent.tagName == 'table:table-header-row') and parent:
				parent = parent.parentNode
			if parent.tagName == 'table-row' or not parent.tagName == 'table-header-row':
				firstrow = parent
				parent = firstrow.parentNode
				parent.removeChild(firstrow)
				firstrow.unlink()
				self.initial_offset = -1

	def merge_document(self, data):
		row_index = 0
		table = self.element('table')
		header_row = self.find_child('table-header-rows', table)
		if not header_row:
			header_row = self.find_child('table-row', table)
		if app.header_from_csv:
			merged_header_row = self.merge_row(header_row, data.row(row_index), row_index + self.initial_offset)
			table.replaceChild(merged_header_row, header_row)
			row_index += 1
			unmerged_template_row = merged_header_row.nextSibling
		else:
			unmerged_template_row = header_row.nextSibling
		for i in range(app.rowSkips):
			unmerged_template_row = unmerged_template_row.nextSibling
		if not unmerged_template_row:  # the template row does not exist
			self.stop(_("Error: A row of sample data was not provided in the template file."), 1)
		if app.verbose:  # display verbose report
			i = self.filename.rfind('/') + 1
			if i == -1: i = 0
			print(self.filename[i:], _("has"), len(unmerged_template_row.getElementsByTagName('text:p')), _("columns."))
		# insert the first row of data into the template row
		template_row = self.merge_row(unmerged_template_row, data.row(row_index), row_index + self.initial_offset)
		table.replaceChild(template_row, unmerged_template_row)
		row_index += 1
		# insert the remaining rows of data
		insert_point = template_row.nextSibling
		for row_index in range(row_index, data.rows()):
			data_row = data.row(row_index)
			merged_row = self.merge_row(template_row, data_row, row_index)
			table.insertBefore(merged_row, insert_point)

	def merge_row(self, template_row, data_row, row_index):
		output_row = template_row.cloneNode(1)
		cell = output_row.firstChild
		for cell_index in range(len(data_row) + app.colSkips):
			if cell.firstChild is None:  # an empty cell is in the template
				self.stop(_("Error: There are too few or missing columns in the template file sample data."), 1)
			data_column = app.order[cell_index]
			if data_column is None:
				data_item = ""
			else:
				data_item = data_row[data_column]
			merged_cell = self.merge_cell(cell, data_item, row_index)
			output_row.replaceChild(merged_cell, cell)
			cell = merged_cell.nextSibling
		return output_row

	def merge_cell(self, template_cell, data_item, row_index):
		output_cell = template_cell.cloneNode(1)
		if output_cell.hasAttribute('table:formula'):
			formula = output_cell.getAttribute('table:formula')
			formula = self.formula_offset(formula, row_index)
			output_cell.setAttribute('table:formula', formula)
		if output_cell.hasAttribute('office:value'):
			output_cell.setAttribute('office:value', data_item)
		if output_cell.hasAttribute('office:date-value'):
			output_cell.firstChild.firstChild.data = ""  # if it's a date, leave the cell text empty
			output_cell.setAttribute('office:date-value', self.format_date(data_item))
		else:
			output_cell.firstChild.firstChild.data = data_item  # if it's not a date, put the value in the cell text
		return output_cell

	def element(self, element_name, occurance=1, node=None):
		'''Search nodes for an element.  Descend into child nodes.'''
		if node == None:
			node = self.content
		num_found = 0
		for child in node.childNodes:
			if child.nodeType == self.content.ELEMENT_NODE and child.localName == element_name:
				num_found += 1
				if num_found >= occurance:
					return child
			if child.hasChildNodes():
				found_in_child = self.element(element_name, occurance-num_found, child)
				if found_in_child:
					num_found += 1
					if num_found >= occurance:
						return found_in_child
		return None

	def find_child(self, element_name, node, occurance=1):
		'''Search nodes for an element.'''
		num_found = 0
		for child in node.childNodes:
			if child.nodeType == self.content.ELEMENT_NODE and child.localName == element_name:
				num_found += 1
				if num_found >= occurance:
					return child
		return None

	def format_date(self, date_in):
		'''reformat a date string to a standard format'''
		if len(app.dateformat) > 0:
			try:
				return self.time.strftime('%Y-%m-%dT%H:%M:%S',self.time.strptime(date_in, app.dateformat))
			except ValueError:
				self.stop(_("The date format ["+app.dateformat+"] could not be interpreted for data: ")+date_in, 1)
		else:
			return date_in

	def formula_offset(self, formula, location):
		'''Alter a spreadsheet formula so that cell references are offset to the current location.
			inputs:
			formula 	a string containing the formula
			location	the current data row where the first data row is 0 '''
		output = ""
		remainder = formula
		previous = 0
		for match in self.re.finditer('[a-zA-Z][0-9]+', formula):
			value = int(formula[match.start()+1:match.end()])
			output += formula[previous:match.start()+1] + str(value + location)
			remainder = formula[match.end():]
			previous = match.end()
		return output + remainder

	def insert_dates(self, node=None):
		'''Search nodes for [date] keywords in text, replace with current time.  Descend into child nodes.'''
		if node == None: # a node was not provided, use root of document content
			node = self.content
		for child in node.childNodes:
			if child.nodeType == self.content.TEXT_NODE:
				child.data = self.insert_date(child.data)
			if child.hasChildNodes():
				self.insert_dates(child)

	def insert_date(self, string):
		'''Searches for a date tag like [date]
		or a date tag with a format like [date %Y-%m-%d]
		or a date tag with an offset like [date-1] in days
		and replaces it with the local date. '''
		if string == None:
			return None
		position = 0
		start = string.lower().find("[date", position)
		position = start
		while start >= 0:
			end = string.find("]", position)
			if end == -1:
				position = start + 1
				continue
			date_spec = string[start+5:end]
			offset = 0
			if date_spec.startswith("+") or date_spec.startswith("-"):
				# there will be a date offset
				end_of_offset = date_spec.find(" ", 1)
				if end_of_offset == -1:
					end_of_offset = end
				try:
					offset = int(date_spec[0:end_of_offset])
					date_spec = date_spec[end_of_offset:]
				except ValueError:
					# the string cannot be interpreted, assume it should be part of the date format and not an offset
					offset = 0
			date_spec = date_spec[1:]	# eliminate the space before the time format
			if not date_spec:
				date_spec = "%Y-%m-%d"
			time_string = self.time.strftime(date_spec, self.time.localtime(self.time.time()+offset*86400))
			string = string[:start] + time_string + string[end+1:]
			position = start + len(time_string)
			start = string.lower().find("[date", position)
		return string

	def repackage(self, out_filename):
		'''Take an odf document and pass each file contained in it to the output except replace content.xml with data.'''
		success = 0
		if app.xml:  # output an xml file, not an odf
			outputfile = open(out_filename,'w')
			if sys.version_info[0] >= 3:
				outputfile.write(self.content.toxml())
			else:
				outputfile.write(self.content.toxml().encode('utf-8'))
			outputfile.close()
			success = 1
		else:  # output an odf file
			documentfile = self.zipfile.ZipFile(self.filename,'r')
			try:
				outputfile = self.zipfile.ZipFile(out_filename,'w')
			except:
				documentfile.close()
				self.stop(_("Error opening output: ")+out_filename, 1)
			try:
				for name in documentfile.namelist():
					if name == "content.xml":
						outputfile.writestr(name, self.content.toxml().encode('utf-8'))
						success = 1
					else:
						content = documentfile.read(name)
						outputfile.writestr(name, content)
			finally:
				documentfile.close()
				outputfile.close()
		return success

	def stop(self, message="", errnum=0):
		'''Terminate the program with a message.'''
		print(message)
		sys.exit(errnum)

	def content():
		return self.content

	# end class document_processor

class incoming_data_source:

	#properties
	filename = ""
	buffer = []

	# these app variables are used:
	#app.start
	#app.end
	#app.delimiter
	#app.verbose

	def read_csv(self):
		'''Read a csv file and split each line into lists of data elements.'''
		inputfile = open(self.filename,'r')
		databuffer1 = inputfile.read()
		inputfile.close()
		#------------------
		quote='"'
		row = []
		element = ""
		within_quote = 0
		cr = '\r'
		end_of_line='\n'
		rows_in = 0
		rows_out = 0
		for i in range(len(databuffer1)):
			c = databuffer1[i]
			if within_quote:
				if c == quote and ( databuffer1[i+1] in (app.delimiter, end_of_line) or i+1 == len(databuffer1) or (databuffer1[i+1]==cr and databuffer1[i+2]==end_of_line) ):
					# This quote is at the end of the field, exit within_quote mode
					within_quote = 0
				elif c == quote and databuffer1[i+1] == quote:
					# This is a dual double-quote, convert to a single double-quote
					continue
				else:
					element += c
			else:
				if c == app.delimiter:
					# end of a field
					row.append(element)
					element = ""
				elif c == quote and not element:
					within_quote = 1
				elif c == end_of_line:
					rows_in += 1
					if rows_in >= app.start and (rows_in <= app.end or app.end == 0):
						row.append(element)
						self.buffer.append(row)
						rows_out += 1
					element = ""
					row = []
				elif c == cr and (databuffer1[i+1] == end_of_line or not element):
					continue
				else:
					element += c
		#-----------------
		if app.verbose:
			# display verbose report
			i = self.filename.rfind('/') + 1
			if i == -1: i = 0
			print(self.filename[i:], _("has"), rows_out, _("rows and"), len(self.buffer[0]), _("columns."))

	def item(self, row, col):
		'''Return a data item at the specified row and column position.'''
		if row == None or col == None:
			return None
		else:
			return self.buffer[row][col]

	def row(self, row):
		'''Return a row of data.'''
		return self.buffer[row]

	def rows(self):
		'''Return the number of rows.'''
		return len(self.buffer)

	def columns(self):
		'''Return the number of columns.'''
		return len(self.buffer[0])

	def content(self):
		return self.buffer

	def __init__(self, filename):
		self.filename = filename
		self.read_csv()

	# end class incoming_data_source

if __name__ == "__main__":
	app = application_initializer()
	document = document_processor(app.document_file)
	app.test_args()
	document.insert_dates()
	if not app.nodata:
		data = incoming_data_source(app.csv_file)
		if not app.order: # if no order was specified, setup the default
			app.order = range(data.columns())
		document.merge_document(data)
	document.repackage(app.out_file)

#kate: tab-width 4;
